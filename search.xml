<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2_一本你可能会喜欢的小说</title>
      <link href="/2022/05/14/mei-qian-shang-da-xue-de-wo-zhi-neng-qu-tu-long-liao/"/>
      <url>/2022/05/14/mei-qian-shang-da-xue-de-wo-zhi-neng-qu-tu-long-liao/</url>
      
        <content type="html"><![CDATA[<p><strong>全文手打，没一个字是复制的</strong></p><p>持续更新(更新速度取决于我最近有没有时间看)~</p><h1 id="没钱上大学的我只能去屠龙了"><a href="#没钱上大学的我只能去屠龙了" class="headerlink" title="没钱上大学的我只能去屠龙了"></a>没钱上大学的我只能去屠龙了</h1><blockquote><p>作者：宇宙无敌水哥</p></blockquote><p><em>书名和作者名着实令人劝退，但实际上是一本写的非常不错龙族同人</em></p><blockquote><p>当一个陌生的人来到陌生的城市的时候，他所仰视的每一座摩天大厦都会以陌生的面孔俯视着他，整座城市都像是在居高临下地审视这个陌生人，冷漠地考虑是将他吞进去吃干抹净，还是憎恶地吐出去。</p><p>我记得有人跟我说过：只要抬头看着蓝天，我就知道我还有地方可以回去。</p><p>她的建议是既然不喜欢就要远离她，离得远远地不要做任何的回应，因为这种暗恋就像黑暗里的蛾子，但凡见到一点光线，他就会以为那是世界上最明亮的太阳…太阳永远会从东边升起，他们心里的期望永远烧不干净，会在地上留下灰尘，一边卑微到泥土里，又一边期望以灰尘为养料，在泥土里开出花来。</p><p>他们这些人做一件事情，一次不够就两次，一天不行就两天，一个星期，一个月，一年，三年，十年，乃至一辈子，没有把时间用干净就不配说无缘，直到倒进坟墓里要洒上棺盖上的那捧泥土之前，才有资格用最后一口气说这辈子无缘无份。</p><p>毕竟人这种东西，可以死在结局里，但一定不能死在路上。</p><p>young people do young thing</p><p>“当着人家的面拆开礼物不显得很失礼吗？”  “在我们那边没这个说法，礼物这种东西本来就是拆开来看的，分享喜悦才是礼物最大的意义”</p><p>是啊，太突然了，他只能想到突然两个字，突然自己为数不多的朋友就要出国了，突然身边的人全都找到新方向了，突然这座城市里说得上烂话的人就又少一个了。</p><p>他抽了抽鼻子感觉隔着手机屏幕都能闻到火锅底料的香味，眼下天气也是够给面子的，一筷子火锅蘸着倒春寒的晚风作佐料，好像能将春夏两个季节一起热腾腾地吞下去。</p><p>“并不是所有女孩子都是用糖果，香料以及一切美好的东西做成的。有些女孩生来即代表冒险，美酒，智慧与无所畏惧。她们像飞鸟、流星、夏日正好的阳光、拂面而来的春风，带着生机勃勃的气息拥抱你。”</p><p>“嗯，我现在知道，但那时侯只感觉你终于厌烦我了，满伤心的，那晚上我回去之后翻了火锅店里那首歌来听，反复听…有些怪矫情的，之后我也觉得有些好笑，但每次听见有人放那首歌就烦的要死…”   “伤心的人听什么歌都感觉是在唱自己。”(本人表示太对了！！)</p><p>都说分手有三个阶段，第一阶段是埋怨现在，然后就是怀念过去，再就是向前走。没有什么感情是可以藕断丝连到带入坟墓的——可能是有的，但它发生的概率太过渺小了，小到可以忽略不去计算。</p><p>打游戏这方面还得是看我们男孩子的(游戏大男子主义)，女孩子还是哭着玩4399换装游戏去吧。这些屁话…他当然没有直接说出来。(当时看到这里直接笑死)</p><p>《等一个人咖啡里》里说，用十年后的自己站在现在的角度看待现在的事情，你就会发现，也许十年后的自己根本就不在乎这些事情。</p><p>嘿，这是在干嘛？表白求爱吗？只是这种腔调是不是太过卑微了一些？朋友，你还小，还不理解，所有的爱情的禁忌都是不能存在上下级权力的啊，你们应该彼此互相珍惜，而不是卑微地祈求对方来爱你。</p><p>颓废的成因是：做过于轻松的事情，过于懒惰而无法做好事情，欣赏太多的艺术，喜好怪诞的东西——伏尔泰《巴比伦公主》</p><p>a body that can rise the moon must carry countless sunsets</p><p>喜欢在玻璃里寻自己的影子的人都是孤独脆弱的，因为明亮的镜子对于他们来说倒影地太过于真切、残忍了，看见里面那不加修饰的真实，会让他们从心底里涌起不适和恐惧。而玻璃…玻璃却是再好不过了，模糊的影子在浑噩的天光的加持下晦暗难明，里面浑浊影子的脸可以成为他们想要的任何模样，给予他们一点点安慰。</p><p>重逢这种事情，不能带着愁眉苦脸，应当带着笑容和美好的情绪，就像窗外穿透雪花的阳光，即使是在再冬的冬日里，也总该有那一束温暖照在人的脖颈上，带给他们寒冬里为数不多的暖意。</p><p>“是平稳而一成不变的生活”  “在一年前这是我的梦想，而现在我的梦想达成了，她不用每天起早贪黑地往外跑，而是有时间坐在图书馆里学习自己喜欢的东西，想买什么咬咬牙就可以买，不至于每次路过的时候都得转头看着我假装跟我聊天回避视线，我能感觉到她在里过得很开心…比以前任何时候都要轻松，这是我做梦都想看到的。”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
            <tag> 龙族 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与差分</title>
      <link href="/2022/05/14/qian-zhui-he-yu-chai-fen/"/>
      <url>/2022/05/14/qian-zhui-he-yu-chai-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="前缀和介绍"><a href="#前缀和介绍" class="headerlink" title="前缀和介绍"></a>前缀和介绍</h2><p>其实前缀和与其说是一种算法，倒不如说是一个小技巧，在各类算法题中几乎不会单独出现，但却是很多算法题的关键步骤，而很多时候我们又会忘记使用这个小技巧从而导致超时。</p><h2 id="前缀和思想"><a href="#前缀和思想" class="headerlink" title="前缀和思想"></a>前缀和思想</h2><p>对数组<code>a[ ]</code>建立一个新的数组<code>s[ ]</code>,<code>s[i]</code>表示 <code>a[1] + a[2] + .. + a[i]</code>的和</p><p>数组<code>s[ ]</code>的作用就是快速求出区间<code>[l, r]</code>的区间和，一般适用在在数据很大时会频繁对数列进行求和的情况下,每次计算区间和的时间复杂度减少到o(1)。</p><h2 id="前缀和模板"><a href="#前缀和模板" class="headerlink" title="前缀和模板"></a>前缀和模板</h2><p>假设是对数组<code>a[]</code>的区间<code>[l, r]</code>进行求和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void init_presum(int a[], int s[]){//构造前缀和s[]数组    for(int i = 1; i &lt;= N; i ++ ) s[i] = s[i - 1] + a[i];    //注：s[]数组初始情况下s[0]默认为0，这样可以更好的处理边界问题}int find_presum(int a[], int l, int r){//使用s[]数组进行查询区间和   return s[r] - s[l - 1]; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实还有二维的前缀和，思路和一维差不多，也很容易写出来这里就不多进行阐述了。</p><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="差分思想"><a href="#差分思想" class="headerlink" title="差分思想"></a>差分思想</h2><p>之所以把差分和前缀和放在一起写是因为差分其实就是前缀和的逆操作。</p><p>我们仍基于数组<code>a[ ]</code>构造一个新数组<code>b[ ]</code>,而<code>a[i]</code>表示数组<code>b[1] + b[2] + .. +b[i]</code>的和。</p><p>这样单纯的看起来好像觉得数组<code>b[ ]</code>没啥用，可实际上在规模庞大的数据基础上如果要频繁的修改某些区间上的值时，这个技巧就很适用，可以将原本o(n)的时间复杂度降到o(1)。</p><p>具体的操作就当修改区间<code>[l, r]</code>时，不用从原数组<code>a[ ]</code>中一个个改，只需要修改数组<code>b[l]、 b[r + 1]</code>的值就可以了，通过<code>b[ ]</code>能很轻松的更新<code>a[ ]</code></p><h2 id="差分模板"><a href="#差分模板" class="headerlink" title="差分模板"></a>差分模板</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insert(int l, int r, int c){    b[l] += c;    b[r + q] -=c;}for (int i = 1; i &lt;= n; i ++ ) b[i] = insert(i, i, a[i]);//数组b[]的构建//将a[]视为全0的数组，因此b[]一开始也是全0。b可以将a的初始化视为对区间长度为1的'点'进行修改实现自己的构建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，二维差分也是存在的，思路还是差不多，这里就不重复写了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分算法</title>
      <link href="/2022/05/13/suan-fa-er-fen/"/>
      <url>/2022/05/13/suan-fa-er-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><h2 id="二分算法思想"><a href="#二分算法思想" class="headerlink" title="二分算法思想"></a>二分算法思想</h2><p>其实很多人认为只有具有<strong>单调性</strong>的数列才能用二分，其实不是。</p><p>单调序列一定能二分，能二分的却不一定时单调序列。</p><p>二分的实质其实是根据元素集合中的<strong>某种性质</strong>来找出<strong>性质的边界</strong>。</p><p>基本步骤为：</p><p>1、确定分界点，一般为<code>mid = l + r &gt;&gt; 1</code></p><p>2、确定分界点的判断函数<code>check()</code></p><p>3、根据判断结果的真和假来划分区间</p><h2 id="二分模板"><a href="#二分模板" class="headerlink" title="二分模板"></a>二分模板</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p><img src="https://cdn.jsdelivr.net/gh/mockingbirdm/picgodemo/img/%E4%BA%8C%E5%88%86%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86.png"></p><p>整型二分的模板右两种</p><p><strong>1、想找出边界的第一个点(例如 图中的B点)</strong></p><p>假设想找出最后一个小于等于 <code>X</code> 的点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(l &lt; r){    int mid = l + r &gt;&gt; 1;//1、确定分界点if (mid &gt;= x) r = mid;//2、确定判断函数；3、划分区间else l = mid + 1;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>注：这里只是举了一个具体的例子，实际上如果将区间<code>[l,r]</code>划分区间为<code>[l，mid]</code>或<code>[mid + 1, r] </code>都可使用</em></p><p><strong>2、想找出边界的最后一个点（例如 如中的A点）</strong></p><p>假设想找出第一个大于等于 <code>X</code> 的点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(l &lt; r){    int mid = l + r + 1 &gt;&gt; 1; //注意这里加了1    if(mid &lt;= x) l = mid;    else r = mid - 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为<code>c++</code>中除法是向下取整，如果此时<code>r = l + 1</code>那么此时更新区间左端点的步骤<code>l = mid</code>实际没有作用，会陷入死循环中</p><p><em>注：这里只是举了一个具体的例子，实际上如果将区间<code>[l,r]</code>划分区间为<code>[l，mid - 1]</code>或<code>[mid , r] </code>都可使用</em></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型就要简单多了，没那么多的区间限制</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(l &lt; r){    int mid = l + r &gt;&gt; 1;    if (check(mid)) r= mid;    else l = mid;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>巨简单！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2022/05/12/suan-fa-pai-xu-gui-bing/"/>
      <url>/2022/05/12/suan-fa-pai-xu-gui-bing/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序-二路归并"><a href="#归并排序-二路归并" class="headerlink" title="归并排序(二路归并)"></a>归并排序(二路归并)</h1><h2 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a>归并排序思想</h2><p><strong>1、确定分界点</strong></p><p>找分界点的方式一般都为找中点即 <code>mid = l + r &gt;&gt; 1</code></p><p><strong>2、递归左区间和右区间</strong></p><p>注意：快速排序中是先调整好区间再进行递归调用</p><p><strong>3、合二为一(难点)</strong></p><p>需要一个额外的数组来暂存合并好的数组</p><h2 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int q[], int l, int r){    if(l &gt;= r) return ; //递归出口    int mid = l + r &gt;&gt; 1;//第一步：确定分界点    merge_sort(q, l, mid),merge_sort(q, mid + 1, r);//第二步：递归调用    int k = 0, i = l, j = mid + 1;    while(i &lt;= mid &amp; j &lt;= r){//第三步：合二为一        if(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//注：这里的 &gt;= 可保证排序的稳定        else tmp[k ++ ] = q[j ++ ];    }    while(i &lt;= mid ) tmp[k ++ ] = q[i ++ ];    while(j &lt;= r) tmp[k ++ ] = q[j ++ ];    for(i = l, j = 0; i &lt;= r; i++, j++ ) q[i] = tmp[j];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="逆序对的数量—题目讲解"><a href="#逆序对的数量—题目讲解" class="headerlink" title="逆序对的数量—题目讲解"></a>逆序对的数量—题目讲解</h2><p><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>可能有的朋友第一次读完题后觉得很莫名奇妙，这和归并排序有关？什么玩意？</p><p>但这确实是一道归并排序的模板题。</p><p>在此之前我们首先要搞清楚什么是<strong>逆序对</strong>，在<code>2,1,4,5,3</code>像&lt;2,1&gt;, &lt;4,3&gt;, &lt;5,3&gt;这样的即为逆序对</p><p>在搞清楚什么是逆序对之后我们就需要考虑它的出现方式，假设我们将一个数列划分为左右两个区间，那么逆序对出现的情况无非就三种</p><p>1、两个数均在左区间</p><p>2、两个数均在右区间</p><p>3、一个数在左区间一个数在右区间</p><p>欸！看到这里是不是马上想到了如果将一个区间视为一个新的数列，那我们实际只需要考虑第三种情况了！</p><p>假如数列的区间划分为为 <code>4 5 6| 1 2 3</code>，那么很明显 如果右区间的最大数小于左区间的最小数，那么立马就能用简单的数学运算得出这个数与左区间形成的逆序对数量 ;</p><p>所以现在的问题是如何找到每次各区间的最小最大数</p><p><del>这多简单？两个for循环不就搞定了？</del> 很显然这样的时间复杂度是o(n^2)</p><p>而归并排序不就恰好能实现这一点吗？而且相应的时间复杂度是o(nlogn)</p><p>所以其实这道题就只需要在归并排序原基础上添加一行代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(i &lt;= mid &amp;&amp; j &lt;= r){    if(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];    else {        tmp[k ++ ] = q[j ++ ];        nums += mid - l + 1;//新添加的一行代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于归并排序你可能想要知道的"><a href="#关于归并排序你可能想要知道的" class="headerlink" title="关于归并排序你可能想要知道的"></a>关于归并排序你可能想要知道的</h2><p>1、该排序算法属于分治法。</p><p>2、该排序算法的时间复杂度稳定的是o(nlogn)不会变动。<em>注: 实际上此处的log是以2为底的</em></p><p>3、该算法其实是以用空间换时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/05/11/suan-fa-pai-xu-kuai-pai/"/>
      <url>/2022/05/11/suan-fa-pai-xu-kuai-pai/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="快排思想——分治"><a href="#快排思想——分治" class="headerlink" title="快排思想——分治"></a>快排思想——分治</h2><p><strong>1.确定分界点</strong></p><p>常用的方式有：<code>q[l]</code> 、<code>q[(l + r) / 2]</code>，<code>q[r]</code></p><p><strong>2.调整区间(难点)</strong></p><p>假设确定好的分界点的值是<code>x</code>则调整后的左区间所有元素均 &lt;= <code>x</code>,右区间的所有值均 &gt;= <code>x</code></p><p>Q：如何优雅的将其分成两个区间？</p><p>小k：简单，再新建两个临时数组<code>tmp1[],tmp2[]</code>,小于基准点的放入第一个，大于基准点的放入第二个，最后再都放入原数组。(暴力的)</p><p><em>这种做法是典型的以空间换时间，如果不太记得优雅的方法的界限划分时倒也不失为一种方法</em></p><p><strong>3.递归处理左右两端</strong></p><h2 id="快排模板"><a href="#快排模板" class="headerlink" title="快排模板"></a>快排模板</h2><p>优雅的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r){    if(l &gt;= r) return;//终止条件    int x = q[l + r &gt;&gt; 1];//第一步，确定分界点    int i = l - 1, j = r + 1;//注意这里的取值，因为下面使用的是do-while所以需要往两边扩一下    while(i &lt; j){//第二步，调整左右区间        do i ++ ; while(q[i] &gt;= x);   do j -- ; while(q[j] &lt;= x);        if(i &lt; j) swap(q[i], q[j]);    }    quick_sort(q, l, j), qucik_sort(q, j + 1, r);//第三步，递归处理左右两端；注意：这里的分界区间，天坑！！(都是泪)，和以首个元素为基准点的划分不一样，且以中间元素为基准点的划分每一次不会确定一个点的最终位置}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第k小的数—模板题"><a href="#第k小的数—模板题" class="headerlink" title="第k小的数—模板题"></a>第k小的数—模板题</h2><p><a href="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k 小的数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>提示：用 k 和要递归的区间左比较，确定在哪个区间就行</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐(live)推荐</title>
      <link href="/2022/03/28/yin-le/"/>
      <url>/2022/03/28/yin-le/</url>
      
        <content type="html"><![CDATA[<p><strong>注：需要用梯子才能打开的链接用X进行标识</strong></p><p>持续更新~</p><h1 id="林志炫"><a href="#林志炫" class="headerlink" title="林志炫"></a>林志炫</h1><p><a href="https://www.bilibili.com/video/BV1BZ4y1f77S/?spm_id_from=333.788.recommend_more_video.9">这世界那么多人——时光音乐会</a></p><p>看飞机轰的一声去远方。</p><p><a href="https://www.bilibili.com/video/BV1Ua41127TA?spm_id_from=333.337.search-card.all.click">【时光音乐会】林志炫超时空和80岁的自己合唱《散了吧》_哔哩哔哩_bilibili</a></p><p>我就是不能看心爱的人显得为难。</p><p><a href="https://www.youtube.com/watch?v=h5gwlEtKWgY">烟花易冷——我是歌手</a> X</p><p>词太美了，没有偏爱的一句</p><p><a href="https://www.youtube.com/watch?v=xP7Ct89lEuM">空——披荆斩棘的哥哥</a> X</p><p>云飘零，风不离。</p><p><a href="https://www.bilibili.com/video/BV1DF411b77L/?spm_id_from=333.788.recommend_more_video.-1">【时光音乐会】林志炫《三生三世》像极了音乐剧男主角_哔哩哔哩_bilibili</a></p><p>要遇多少风浪，心不再摇晃~</p><h1 id="陈奕迅"><a href="#陈奕迅" class="headerlink" title="陈奕迅"></a>陈奕迅</h1><p><a href="https://www.bilibili.com/video/BV1qK4y1W71X?spm_id_from=333.337.search-card.all.click">【4K30FPS】陈奕迅《黑夜不再来》神级现场！最强版本！_哔哩哔哩_bilibili</a></p><p>熟悉的想讲再会，陌生的都很匹配。</p><p><a href="https://www.bilibili.com/video/BV11Z4y157y1?spm_id_from=333.337.search-card.all.click">【4K60FPS】陈奕迅《喜帖街》超感人现场！我回来了！_哔哩哔哩_bilibili</a></p><p>忘掉种过的花，重新的出发，放弃理想把。</p><p><a href="https://www.bilibili.com/video/BV1Pv411E7Jg/?spm_id_from=333.788.recommend_more_video.1">【4K60FPS】陈奕迅《约定》神级现场！两鬓斑白都可认得你！_哔哩哔哩_bilibili</a></p><p>两鬓斑白都可认得你。</p><p><a href="https://www.bilibili.com/video/BV1H3411C7ZJ/?spm_id_from=333.788.recommend_more_video.1">【4K60FPS】陈奕迅《富士山下》神级现场！你听懂了吗？_哔哩哔哩_bilibili</a></p><p>我绝不罕有，往街里绕过一周，我便化乌有。</p><p><a href="https://www.bilibili.com/video/BV1M44y1M7uT?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click">【4K60FPS】陈奕迅、蔡健雅《达尔文》神仙组合! 原本是写给陈奕迅的歌，这场也算是陈奕迅补偿了当初拒绝蔡健雅的这一丝遗憾吧_哔哩哔哩_bilibili</a></p><p>有过竞争，有过牺牲，被爱筛选过程。</p><p>学会认真，学会忠诚，适者才能生存。</p><h1 id="民间大佬"><a href="#民间大佬" class="headerlink" title="民间大佬"></a>民间大佬</h1><p><a href="https://www.bilibili.com/video/BV1Ta41187Hh?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click">吉他弹唱：《天龙八部之宿敌》_哔哩哔哩_bilibili</a></p><p>我借你的孤胆，今生恐怕难还。</p><p><a href="https://www.bilibili.com/video/BV1RZ4y1f7Hp?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click">男孩别哭_哔哩哔哩_bilibili</a></p><p>那些城市上飘动着一颗颗不安的心。</p><p>有些人，听着听着就打开了全民k歌</p><p>三分钟后，关闭，退出，一起呵成</p><p>是谁我不说[狗头]</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>或许是一些道理</title>
      <link href="/2022/03/26/luo-xiang/"/>
      <url>/2022/03/26/luo-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="罗翔"><a href="#罗翔" class="headerlink" title="罗翔"></a>罗翔</h2><p><strong>1、时间</strong></p><p><em>昨天的已经成为过去，明天的还未到来，所以今天是一个礼物</em>——《奥古斯丁忏悔录》</p><p>去享受和珍惜这种平凡的幸福，现在你觉得平凡但当你失去的那天你会觉得它是如此珍贵。</p><p><strong>2、管束</strong></p><p><em>在完全自由的状态下人类会主动走向堕落，所以需要被限制和管束</em></p><p><strong>3、平庸</strong></p><p><em>每天所从事的工作生活太过于平庸，太过于没有意义，我们寻求一种超越的方式。有人用吸毒、性的放纵等各种方式来对抗生活的平庸，但这些方法都是错误的。</em></p><p><strong>4、快乐</strong></p><p><em>有人说，人这一生，都应该追求什么呢，都应该追求快乐，其实吸毒是不是也是在追求快乐，既在追求快乐，又在追求超越，想对抗我们平庸的生活，但是各位注意，其实快乐是有质和量的区别，</em></p><p><em>假如一本小黄书、郭德纲的相声、莎士比亚作品能给你带来同样大小的快乐，你会选择哪一本书？那如果只能留一本书给你的子孙后代，你又会选择哪一本书？</em></p><p><em>越能体现人类尊严的快乐，越是一种最大的快乐，它是和人的尊严有关的。有很多快乐是放纵的快乐，是降低了人性的尊严，而越是能体现人的尊严的快乐越是一种高级的快乐。</em></p><p><em>我们之所以读书行路，其实就是希望我们能够不断的享受高级快乐</em></p><p><em>当你享受高级快乐并不会失去低级快乐，我读莎士比亚并不妨碍我读郭德纲的相声。但如果你的眼目永远只关注地下，你永远不知道向上看有多么的快乐。</em></p><p><strong>5、困境</strong></p><p><em>很多时候吧，你改变不了你所处的情境，你只能勇敢面对你所出现的情境</em></p><p><em>当然怨天尤人是种选择，但怨天尤人最后害的是谁呢？当然是你自己</em></p><p><em>古希腊哲学家埃比克泰德曾经说出过一句著名的话，他说我们登上并非我们所选择的舞台，演出非我们所选择的剧本。有谁是自愿来到这个世界上的，有谁来到这个世界上父母征求过你的意见，有谁的智商、长相是你自己选择的，大家是不是很羡慕别人的剧本，但是没有办法，你的剧本不是你的选择，你只有努力把你的剧本给演好，虽然很痛苦，但只要努力演好你的剧本，在痛苦中也有精彩。</em></p><p><em>感到空虚时，学会用知识来填充而并非爱欲</em></p><h2 id="纪伯伦"><a href="#纪伯伦" class="headerlink" title="纪伯伦"></a>纪伯伦</h2><p><strong>《我曾七次鄙视自己的灵魂》</strong></p><p><em>第一次，当它本可进取时，却故作谦卑</em></p><p><em>the first time when i saw  her being meek that she might attain height</em></p><p><em>第二次，当它本可空虚时，用爱欲来填充</em></p><p><em>the second time when i saw her limping before the crippled</em></p><p><em>第三次，在困难和容易之间，它选择了容易</em></p><p><em>the third time when she was given to choose between the hard and the easy, and she chose the easy</em></p><p><em>第四次、它犯了错，却借由别人也会犯错来宽慰自己</em></p><p><em>the fourth time when she committed a wrong, and comforted herself that others also commit wrong</em></p><p><em>第五次、它自由软弱、却把它认为是生命的坚韧</em></p><p><em>the fifth time when she forbore for weakness, and attributed her patience to strength</em></p><p><em>第六次、当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副</em></p><p><em>the sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks</em></p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 罗翔 </tag>
            
            <tag> 纪伯伦 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
