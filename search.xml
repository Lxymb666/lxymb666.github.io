<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>归并排序</title>
      <link href="/2022/05/12/suan-fa-pai-xu-gui-bing/"/>
      <url>/2022/05/12/suan-fa-pai-xu-gui-bing/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序-二路归并"><a href="#归并排序-二路归并" class="headerlink" title="归并排序(二路归并)"></a>归并排序(二路归并)</h1><h2 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a>归并排序思想</h2><p><strong>1、确定分界点</strong></p><p>找分界点的方式一般都为找中点即 <code>mid = l + r &gt;&gt; 1</code></p><p><strong>2、递归左区间和右区间</strong></p><p>注意：快速排序中是先调整好区间再进行递归调用</p><p><strong>3、合二为一(难点)</strong></p><p>需要一个额外的数组来暂存合并好的数组</p><h2 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int q[], int l, int r){    if(l &gt;= r) return ; //递归出口    int mid = l + r &gt;&gt; 1;//第一步：确定分界点    merge_sort(q, l, mid),merge_sort(q, mid + 1, r);//第二步：递归调用    int k = 0, i = l, j = mid + 1;    while(i &lt;= mid &amp; j &lt;= r){//第三步：合二为一        if(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//注：这里的 &gt;= 可保证排序的稳定        else tmp[k ++ ] = q[j ++ ];    }    while(i &lt;= mid ) tmp[k ++ ] = q[i ++ ];    while(j &lt;= r) tmp[k ++ ] = q[j ++ ];    for(i = l, j = 0; i &lt;= r; i++, j++ ) q[i] = tmp[j];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="逆序对的数量—题目讲解"><a href="#逆序对的数量—题目讲解" class="headerlink" title="逆序对的数量—题目讲解"></a>逆序对的数量—题目讲解</h2><p><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>可能有的朋友第一次读完题后觉得很莫名奇妙，这和归并排序有关？什么玩意？</p><p>但这确实是一道归并排序的模板题。</p><p>在此之前我们首先要搞清楚什么是<strong>逆序对</strong>，在<code>2,1,4,5,3</code>像&lt;2,1&gt;, &lt;4,3&gt;, &lt;5,3&gt;这样的即为逆序对</p><p>在搞清楚什么是逆序对之后我们就需要考虑它的出现方式，假设我们将一个数列划分为左右两个区间，那么逆序对出现的情况无非就三种</p><p>1、两个数均在左区间</p><p>2、两个数均在右区间</p><p>3、一个数在左区间一个数在右区间</p><p>欸！看到这里是不是马上想到了如果将一个区间视为一个新的数列，那我们实际只需要考虑第三种情况了！</p><p>假如数列的区间划分为为 <code>4 5 6| 1 2 3</code>，那么很明显 如果右区间的最大数小于左区间的最小数，那么立马就能用简单的数学运算得出这个数与左区间形成的逆序对数量 ;</p><p>所以现在的问题是如何找到每次各区间的最小最大数</p><p><del>这多简单？两个for循环不就搞定了？</del> 很显然这样的时间复杂度是o(n^2)</p><p>而归并排序不就恰好能实现这一点吗？而且相应的时间复杂度是o(nlogn)</p><p>所以其实这道题就只需要在归并排序原基础上添加一行代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(i &lt;= mid &amp;&amp; j &lt;= r){    if(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];    else {        tmp[k ++ ] = q[j ++ ];        nums += mid - l + 1;//新添加的一行代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于归并排序你可能想要知道的"><a href="#关于归并排序你可能想要知道的" class="headerlink" title="关于归并排序你可能想要知道的"></a>关于归并排序你可能想要知道的</h2><p>1、该排序算法属于分治法。</p><p>2、该排序算法的时间复杂度稳定的是o(nlogn)不会变动。<em>注: 实际上此处的log是以2为底的</em></p><p>3、该算法其实是以用空间换时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/05/11/suan-fa-pai-xu-kuai-pai/"/>
      <url>/2022/05/11/suan-fa-pai-xu-kuai-pai/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="快排思想——分治"><a href="#快排思想——分治" class="headerlink" title="快排思想——分治"></a>快排思想——分治</h2><p><strong>1.确定分界点</strong></p><p>常用的方式有：<code>q[l]</code> 、<code>q[(l + r) / 2]</code>，<code>q[r]</code></p><p><strong>2.调整区间(难点)</strong></p><p>假设确定好的分界点的值是<code>x</code>则调整后的左区间所有元素均 &lt;= <code>x</code>,右区间的所有值均 &gt;= <code>x</code></p><p>Q：如何优雅的将其分成两个区间？</p><p>小k：简单，再新建两个临时数组<code>tmp1[],tmp2[]</code>,小于基准点的放入第一个，大于基准点的放入第二个，最后再都放入原数组。(暴力的)</p><p><em>这种做法是典型的以空间换时间，如果不太记得优雅的方法的界限划分时倒也不失为一种方法</em></p><p><strong>3.递归处理左右两端</strong></p><h2 id="快排模板"><a href="#快排模板" class="headerlink" title="快排模板"></a>快排模板</h2><p>优雅的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r){    if(l &gt;= r) return;//终止条件    int x = q[l + r &gt;&gt; 1];//第一步，确定分界点    int i = l - 1, j = r + 1;//注意这里的取值，因为下面使用的是do-while所以需要往两边扩一下    while(i &lt; j){//第二步，调整左右区间        do i ++ ; while(q[i] &gt;= x);   do j -- ; while(q[j] &lt;= x);        if(i &lt; j) swap(q[i], q[j]);    }    quick_sort(q, l, j), qucik_sort(q, j + 1, r);//第三步，递归处理左右两端；注意：这里的分界区间，天坑！！(都是泪)，和以首个元素为基准点的划分不一样，且以中间元素为基准点的划分每一次不会确定一个点的最终位置}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第k小的数—模板题"><a href="#第k小的数—模板题" class="headerlink" title="第k小的数—模板题"></a>第k小的数—模板题</h2><p><a href="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k 小的数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>提示：用 k 和要递归的区间左比较，确定在哪个区间就行</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/2022/03/28/yin-le/"/>
      <url>/2022/03/28/yin-le/</url>
      
        <content type="html"><![CDATA[<p>链接打不开的话可能得用梯子</p><h2 id="林志炫"><a href="#林志炫" class="headerlink" title="林志炫"></a>林志炫</h2><p><a href="https://www.bilibili.com/video/BV1BZ4y1f77S/?spm_id_from=333.788.recommend_more_video.9">这世界那么多人——时光音乐会</a></p><p><a href="https://www.youtube.com/watch?v=h5gwlEtKWgY">烟花易冷——我是歌手</a></p><p><a href="https://www.youtube.com/watch?v=xP7Ct89lEuM">空——披荆斩棘的哥哥</a></p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>或许是一些道理</title>
      <link href="/2022/03/26/luo-xiang/"/>
      <url>/2022/03/26/luo-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="罗翔"><a href="#罗翔" class="headerlink" title="罗翔"></a>罗翔</h2><p><a href="https://www.bilibili.com/video/BV1my4y1u71Q/?spm_id_from=333.788">视频链接</a></p><p><strong>1、时间</strong></p><p><em>昨天的已经成为过去，明天的还未到来，所以今天是一个礼物</em>——《奥古斯丁忏悔录》</p><p>去享受和珍惜这种平凡的幸福，现在你觉得平凡但当你失去的那天你会觉得它是如此珍贵。</p><p><strong>2、管束</strong></p><p><em>在完全自由的状态下人类会主动走向堕落，所以需要被限制和管束</em></p><p><strong>3、平庸</strong></p><p><em>每天所从事的工作生活太过于平庸，太过于没有意义，我们寻求一种超越的方式。有人用吸毒、性的放纵等各种方式来对抗生活的平庸，但这些方法都是错误的。</em></p><p><strong>4、快乐</strong></p><p><em>有人说，人这一生，都应该追求什么呢，都应该追求快乐，其实吸毒是不是也是在追求快乐，既在追求快乐，又在追求超越，想对抗我们平庸的生活，但是各位注意，其实快乐是有质和量的区别，</em></p><p><em>假如一本小黄书、郭德纲的相声、莎士比亚作品能给你带来同样大小的快乐，你会选择哪一本书？那如果只能留一本书给你的子孙后代，你又会选择哪一本书？</em></p><p><em>越能体现人类尊严的快乐，越是一种最大的快乐，它是和人的尊严有关的。有很多快乐是放纵的快乐，是降低了人性的尊严，而越是能体现人的尊严的快乐越是一种高级的快乐。</em></p><p><em>我们之所以读书行路，其实就是希望我们能够不断的享受高级快乐</em></p><p><em>当你享受高级快乐并不会失去低级快乐，我读莎士比亚并不妨碍我读郭德纲的相声。但如果你的眼目永远只关注地下，你永远不知道向上看有多么的快乐。</em></p><p><strong>5、困境</strong></p><p><em>很多时候吧，你改变不了你所处的情境，你只能勇敢面对你所出现的情境</em></p><p><em>当然怨天尤人是种选择，但怨天尤人最后害的是谁呢？当然是你自己</em></p><p><em>古希腊哲学家埃比克泰德曾经说出过一句著名的话，他说我们登上并非我们所选择的舞台，演出非我们所选择的剧本。有谁是自愿来到这个世界上的，有谁来到这个世界上父母征求过你的意见，有谁的智商、长相是你自己选择的，大家是不是很羡慕别人的剧本，但是没有办法，你的剧本不是你的选择，你只有努力把你的剧本给演好，虽然很痛苦，但只要努力演好你的剧本，在痛苦中也有精彩。</em></p><p><em>感到空虚时，学会用知识来填充而并非爱欲</em></p><h2 id="纪伯伦"><a href="#纪伯伦" class="headerlink" title="纪伯伦"></a>纪伯伦</h2><p><strong>《我曾七次鄙视自己的灵魂》</strong></p><p><em>第一次，当它本可进取时，却故作谦卑</em></p><p><em>the first time when i saw  her being meek that she might attain height</em></p><p><em>第二次，当它本可空虚时，用爱欲来填充</em></p><p><em>the second time when i saw her limping before the crippled</em></p><p><em>第三次，在困难和容易之间，它选择了容易</em></p><p><em>the third time when she was given to choose between the hard and the easy, and she chose the easy</em></p><p><em>第四次、它犯了错，却借由别人也会犯错来宽慰自己</em></p><p><em>the fourth time when she committed a wrong, and comforted herself that others also commit wrong</em></p><p><em>第五次、它自由软弱、却把它认为是生命的坚韧</em></p><p>*the fifth time when she forbore for weakness, and attributed her patience to strength *</p><p><em>第六次、当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副</em></p><p><em>the sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks</em></p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 罗翔 </tag>
            
            <tag> 纪伯伦 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
